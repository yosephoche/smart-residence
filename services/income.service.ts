import { prisma } from "@/lib/prisma";
import { IncomeCategory } from "@prisma/client";

// Check if income is auto-generated (linked to payment)
async function isAutoGenerated(incomeId: string): Promise<boolean> {
  const income = await prisma.income.findUnique({
    where: { id: incomeId },
    select: { paymentId: true },
  });
  return income?.paymentId !== null;
}

// Fetch incomes with optional filtering
export async function getIncomes({
  startDate,
  endDate,
  category,
  createdBy,
}: {
  startDate?: Date;
  endDate?: Date;
  category?: IncomeCategory;
  createdBy?: string;
} = {}) {
  return prisma.income.findMany({
    where: {
      ...(startDate ? { date: { gte: startDate } } : {}),
      ...(endDate ? { date: { lte: endDate } } : {}),
      ...(category ? { category } : {}),
      ...(createdBy ? { createdBy } : {}),
    },
    include: {
      creator: { select: { id: true, name: true, email: true } },
    },
    orderBy: { date: "desc" },
  });
}

// Get single income by ID
export async function getIncomeById(id: string) {
  return prisma.income.findUnique({
    where: { id },
    include: {
      creator: { select: { id: true, name: true, email: true } },
    },
  });
}

// Create new income (admin only)
export async function createIncome(data: {
  date: Date;
  category: IncomeCategory;
  amount: number;
  description: string;
  notes?: string;
  createdBy: string;
}) {
  return prisma.income.create({
    data,
    include: {
      creator: { select: { id: true, name: true, email: true } },
    },
  });
}

// Update existing income (admin only)
export async function updateIncome(
  id: string,
  data: {
    date?: Date;
    category?: IncomeCategory;
    amount?: number;
    description?: string;
    notes?: string;
  }
) {
  // Check if auto-generated
  if (await isAutoGenerated(id)) {
    throw new Error("Cannot edit auto-generated income from approved payments. This income is read-only.");
  }

  return prisma.income.update({
    where: { id },
    data,
    include: {
      creator: { select: { id: true, name: true, email: true } },
    },
  });
}

// Delete income (admin only)
export async function deleteIncome(id: string) {
  // Check if auto-generated
  if (await isAutoGenerated(id)) {
    throw new Error("Cannot delete auto-generated income from approved payments. This income is read-only.");
  }

  return prisma.income.delete({ where: { id } });
}

// Get total incomes for a specific month
export async function getMonthlyIncomes(year: number, month: number) {
  const startDate = new Date(year, month - 1, 1);
  const endDate = new Date(year, month, 0, 23, 59, 59);

  const result = await prisma.income.aggregate({
    _sum: { amount: true },
    where: {
      date: { gte: startDate, lte: endDate },
    },
  });

  return Number(result._sum.amount ?? 0);
}

// Get all-time total incomes
export async function getTotalIncomes() {
  const result = await prisma.income.aggregate({
    _sum: { amount: true },
  });
  return Number(result._sum.amount ?? 0);
}

// Get income statistics with category breakdown
export async function getIncomeStats({
  startDate,
  endDate,
}: {
  startDate?: Date;
  endDate?: Date;
} = {}) {
  const [total, totalAmount, byCategory] = await Promise.all([
    prisma.income.count({
      where: {
        ...(startDate ? { date: { gte: startDate } } : {}),
        ...(endDate ? { date: { lte: endDate } } : {}),
      },
    }),
    prisma.income.aggregate({
      _sum: { amount: true },
      where: {
        ...(startDate ? { date: { gte: startDate } } : {}),
        ...(endDate ? { date: { lte: endDate } } : {}),
      },
    }),
    prisma.income.groupBy({
      by: ["category"],
      _sum: { amount: true },
      _count: true,
      where: {
        ...(startDate ? { date: { gte: startDate } } : {}),
        ...(endDate ? { date: { lte: endDate } } : {}),
      },
    }),
  ]);

  return {
    total,
    totalAmount: Number(totalAmount._sum.amount ?? 0),
    byCategory: byCategory.map((item) => ({
      category: item.category,
      amount: Number(item._sum.amount ?? 0),
      count: item._count,
    })),
  };
}
